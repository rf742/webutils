<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal CAS</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background-color: #0c0c0c;
            color: #33ff00;
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px; /* Slightly smaller for complex output */
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- STACK HUD --- */
        #stack-monitor {
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }
        .stack-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .stack-label { color: #555; font-weight: bold; margin-right: 15px; }
        .stack-value { color: #fff; font-weight: bold; font-family: 'Courier New', monospace; }
        .stack-row.active .stack-label { color: #33ff00; }
        .stack-row.active .stack-value { color: #33ff00; }

        /* --- OUTPUT LOG --- */
        #terminal-output {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            white-space: pre-wrap;
            margin-bottom: 10px;
        }
        #terminal-output::-webkit-scrollbar { width: 8px; }
        #terminal-output::-webkit-scrollbar-thumb { background: #333; }

        /* --- INPUT --- */
        .input-line {
            display: flex;
            align-items: center;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
        .prompt-char { margin-right: 10px; font-weight: bold; user-select: none; }
        input[type="text"] {
            background: transparent;
            border: none;
            color: inherit;
            font-family: inherit;
            font-size: inherit;
            flex-grow: 1;
            outline: none;
            caret-color: #33ff00;
        }

        /* --- LOG COLORS --- */
        .log-entry { margin-bottom: 2px; line-height: 1.3; }
        .log-command { opacity: 0.6; }
        .log-error { color: #ff3333; }
        .log-info { color: #888; font-style: italic; }
        .log-obj { color: #aaaaff; } /* Color for Vectors/Complex output in log */
    </style>
</head>
<body>

    <div id="stack-monitor">
        <div class="stack-row"><span class="stack-label">4:</span><span class="stack-value" id="s4"></span></div>
        <div class="stack-row"><span class="stack-label">3:</span><span class="stack-value" id="s3"></span></div>
        <div class="stack-row"><span class="stack-label">2:</span><span class="stack-value" id="s2"></span></div>
        <div class="stack-row active"><span class="stack-label">1:</span><span class="stack-value" id="s1"></span></div>
    </div>

    <div id="terminal-output">
        <div class="log-entry">CAS Calculator v3.0</div>
        <div class="log-entry">New Types: Vec2, Vec3, Complex</div>
        <div class="log-entry">Use 'v2', 'v3', 'comp' to create them.</div>
        <div class="log-entry">-----------------------------------------</div>
    </div>

    <div class="input-line">
        <span class="prompt-char">&gt;</span>
        <input type="text" id="command-input" autocomplete="off" autofocus>
    </div>

    <script>
        // ==========================================
        //          MATH KERNEL & TYPE SYSTEM
        // ==========================================
        
        // Helper: nice number formatting
        const fmt = (n) => {
            const f = parseFloat(n.toPrecision(10)); // Clean floating point junk
            return Math.abs(f) < 1e-10 ? 0 : f; // Fix -0
        };

        class Vec2 {
            constructor(x, y) { this.x = x; this.y = y; }
            toString() { return `[${fmt(this.x)}, ${fmt(this.y)}]`; }
        }

        class Vec3 {
            constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
            toString() { return `[${fmt(this.x)}, ${fmt(this.y)}, ${fmt(this.z)}]`; }
        }

        class Complex {
            constructor(re, im) { this.re = re; this.im = im; }
            toString() { 
                const sign = this.im >= 0 ? '+' : '-';
                return `${fmt(this.re)} ${sign} ${fmt(Math.abs(this.im))}i`; 
            }
        }

        // --- THE DISPATCHER ---
        // Handles operations between different types (Scalar, Vec, Comp)
        const Dispatcher = {
            // Apply Binary Op (a op b)
            binary: (op, a, b) => {
                // 1. Both Scalars
                if (typeof a === 'number' && typeof b === 'number') {
                    return op.scalar(a, b);
                }

                // 2. Complex Arithmetic
                if (a instanceof Complex || b instanceof Complex) {
                    let cA = a instanceof Complex ? a : new Complex(a, 0);
                    let cB = b instanceof Complex ? b : new Complex(b, 0);
                    return op.complex(cA, cB);
                }

                // 3. Vector Arithmetic
                // If one is scalar, promote it to simulate broadcasting
                if (typeof a === 'number' && b instanceof Vec2) a = new Vec2(a, a);
                if (typeof b === 'number' && a instanceof Vec2) b = new Vec2(b, b);
                if (typeof a === 'number' && b instanceof Vec3) a = new Vec3(a, a, a);
                if (typeof b === 'number' && a instanceof Vec3) b = new Vec3(b, b, b);

                if (a instanceof Vec2 && b instanceof Vec2) {
                    return new Vec2(op.scalar(a.x, b.x), op.scalar(a.y, b.y));
                }
                if (a instanceof Vec3 && b instanceof Vec3) {
                    return new Vec3(op.scalar(a.x, b.x), op.scalar(a.y, b.y), op.scalar(a.z, b.z));
                }

                throw new Error("Type Mismatch");
            },

            // Apply Unary Op (op a)
            unary: (op, a) => {
                if (typeof a === 'number') return op(a);
                
                if (a instanceof Vec2) return new Vec2(op(a.x), op(a.y));
                if (a instanceof Vec3) return new Vec3(op(a.x), op(a.y), op(a.z));
                
                // Complex unary is tricky (e.g. sin(complex)), 
                // for this basic version we only support Magnitude for complex
                // or specific real-part operations.
                if (a instanceof Complex) {
                    throw new Error("Complex unary not fully supported yet");
                }
            }
        };

        // ==========================================
        //           OPERATIONS REGISTRY
        // ==========================================
        
        const OPS = {
            // --- CONSTANTS ---
            'pi': { type: 'const', val: Math.PI },
            'e':  { type: 'const', val: Math.E },
            'i':  { type: 'const', val: new Complex(0, 1) },

            // --- STANDARD BINARY ---
            '+': { type: 'binary', 
                scalar: (a, b) => a + b,
                complex: (a, b) => new Complex(a.re + b.re, a.im + b.im)
            },
            '-': { type: 'binary', 
                scalar: (a, b) => a - b,
                complex: (a, b) => new Complex(a.re - b.re, a.im - b.im)
            },
            '*': { type: 'binary', 
                scalar: (a, b) => a * b, // Element-wise for vectors
                complex: (a, b) => new Complex(
                    a.re * b.re - a.im * b.im, 
                    a.re * b.im + a.im * b.re
                )
            },
            '/': { type: 'binary', 
                scalar: (a, b) => a / b,
                complex: (a, b) => {
                    const denom = b.re * b.re + b.im * b.im;
                    return new Complex(
                        (a.re * b.re + a.im * b.im) / denom,
                        (a.im * b.re - a.re * b.im) / denom
                    );
                }
            },
            'pow': { type: 'binary',
                scalar: (a, b) => Math.pow(a, b),
                complex: (a, b) => { throw new Error("Complex Power not impl"); }
            },

            // --- UNARY (Map over components) ---
            'sin': { type: 'unary', func: Math.sin },
            'cos': { type: 'unary', func: Math.cos },
            'tan': { type: 'unary', func: Math.tan },
            'sqrt':{ type: 'unary', func: Math.sqrt },
            'abs': { type: 'unary', func: Math.abs },
            'exp': { type: 'unary', func: Math.exp },
            'pm': { type: 'custom', func: (a) => {
                if (typeof a === 'number') return -a;
                if (a instanceof Vec2) return new Vec2(-a.x, -a.y);
                if (a instanceof Vec3) return new Vec3(-a.x, -a.y, -a.z);
                if (a instanceof Complex) return new Complex(-a.re, -a.im);
                throw new Error("Invalid type for pm");
            }},

            // --- SPECIAL FUNCTIONS ---
            'mag': { type: 'custom', func: (a) => {
                if (typeof a === 'number') return Math.abs(a);
                if (a instanceof Vec2) return Math.sqrt(a.x**2 + a.y**2);
                if (a instanceof Vec3) return Math.sqrt(a.x**2 + a.y**2 + a.z**2);
                if (a instanceof Complex) return Math.sqrt(a.re**2 + a.im**2);
                throw new Error("Invalid type");
            }},
            
            'dot': { type: 'custom', func: (a, b) => {
                 if (a instanceof Vec2 && b instanceof Vec2) return a.x*b.x + a.y*b.y;
                 if (a instanceof Vec3 && b instanceof Vec3) return a.x*b.x + a.y*b.y + a.z*b.z;
                 throw new Error("Dot requires matching vectors");
            }},

            'cross': { type: 'custom', func: (a, b) => {
                 if (a instanceof Vec3 && b instanceof Vec3) {
                     return new Vec3(
                         a.y*b.z - a.z*b.y,
                         a.z*b.x - a.x*b.z,
                         a.x*b.y - a.y*b.x
                     );
                 }
                 throw new Error("Cross requires 3D Vectors");
            }},

            // --- CONSTRUCTORS ---
            'v2': { type: 'system', func: (s) => {
                if (s.length < 2) return false;
                const y = s.pop(); const x = s.pop();
                // Ensure they are numbers
                if (typeof x !== 'number' || typeof y !== 'number') throw new Error("Args must be scalars");
                s.push(new Vec2(x, y));
                return true;
            }},
            'v3': { type: 'system', func: (s) => {
                if (s.length < 3) return false;
                const z = s.pop(); const y = s.pop(); const x = s.pop();
                s.push(new Vec3(x, y, z));
                return true;
            }},
            'comp': { type: 'system', func: (s) => {
                if (s.length < 2) return false;
                const im = s.pop(); const re = s.pop();
                s.push(new Complex(re, im));
                return true;
            }},

            // --- STACK MANAGEMENT ---
            'swap': { type: 'system', func: (s) => {
                if (s.length < 2) return false;
                const top = s.pop(); const next = s.pop();
                s.push(top); s.push(next);
                return true;
            }},
            's': { type: 'alias', target: 'swap' },
            'drop': { type: 'system', func: (s) => { if(s.length) s.pop(); return true; } },
            'cls': { type: 'system', func: (s) => { 
                s.length = 0; 
                document.getElementById('terminal-output').innerHTML = ''; 
                return true; 
            }}
        };

        // ==========================================
        //          UI & LOGIC
        // ==========================================

        const input = document.getElementById('command-input');
        const output = document.getElementById('terminal-output');
        const uiStack = [
            document.getElementById('s1'), document.getElementById('s2'),
            document.getElementById('s3'), document.getElementById('s4')
        ];

        let stack = [];
        let commandHistory = [];
        let historyIndex = -1;

        function updateDisplay() {
            for (let i = 0; i < 4; i++) {
                let valIndex = stack.length - 1 - i;
                let val = (valIndex >= 0) ? stack[valIndex] : '';
                
                // Polymorphic Display
                if (val && typeof val.toString === 'function') {
                    // It's an object (Vec/Comp)
                    uiStack[i].textContent = val.toString();
                } else if (typeof val === 'number') {
                    uiStack[i].textContent = fmt(val);
                } else {
                    uiStack[i].textContent = val;
                }
            }
        }

        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const raw = input.value;
                if (raw.trim()) {
                    printToLog(`> ${raw}`, 'log-command');
                    try {
                        processLine(raw.trim());
                    } catch (err) {
                        printToLog(`Error: ${err.message}`, 'log-error');
                    }
                    commandHistory.push(raw);
                    historyIndex = commandHistory.length;
                    input.value = '';
                    output.scrollTop = output.scrollHeight;
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    input.value = commandHistory[historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    input.value = commandHistory[historyIndex];
                } else {
                    historyIndex = commandHistory.length;
                    input.value = '';
                }
            }
        });

        document.addEventListener('click', () => input.focus());

        function processLine(line) {
            const tokens = line.split(/\s+/);

            tokens.forEach(token => {
                // Number?
                if (!isNaN(parseFloat(token)) && isFinite(token)) {
                    stack.push(parseFloat(token));
                    return;
                }

                const key = token.toLowerCase();
                const op = OPS[key];

                if (!op) {
                     if (key === 'd' || key === 'drop') { executeOp(OPS['drop']); return; } // fallback
                     throw new Error(`Unknown: ${token}`);
                }
                
                executeOp(op, key);
            });
            updateDisplay();
        }

        function executeOp(op, name) {
            if (op.type === 'alias') return executeOp(OPS[op.target], name);
            if (op.type === 'const') { stack.push(op.val); return; }

            // System: gets raw stack access
            if (op.type === 'system') {
                if (!op.func(stack)) throw new Error("Stack Underflow");
                return;
            }

            // Custom: Manually handles pops (like dot/cross/mag)
            if (op.type === 'custom') {
                // Determine arg count based on function length
                const argsNeeded = op.func.length;
                if (stack.length < argsNeeded) throw new Error("Stack Underflow");
                
                const args = [];
                for(let i=0; i<argsNeeded; i++) args.unshift(stack.pop());
                
                const res = op.func(...args);
                stack.push(res);
                return;
            }

            // Binary Dispatch
            if (op.type === 'binary') {
                if (stack.length < 2) throw new Error("Stack Underflow");
                const b = stack.pop();
                const a = stack.pop();
                stack.push(Dispatcher.binary(op, a, b));
                return;
            }

            // Unary Dispatch
            if (op.type === 'unary') {
                if (stack.length < 1) throw new Error("Stack Underflow");
                const a = stack.pop();
                stack.push(Dispatcher.unary(op.func, a));
                return;
            }
        }

        function printToLog(text, className) {
            const div = document.createElement('div');
            div.className = `log-entry ${className || ''}`;
            div.textContent = text;
            output.appendChild(div);
        }

        updateDisplay();
    </script>
</body>
</html>